// /pages/api/ml/match.ts - CORRECTED VERSION (Trainers visible before spin)
import type { NextApiRequest, NextApiResponse } from 'next';
import { createSupabaseServer } from '../../../lib/supabase/server';
import { matchRequestSchema } from '../../../lib/validators';

// Mock embedding similarity function (from Phase 16)
function cosineSimilarity(a: number[], b: number[]): number {
  if (!a || !b || a.length !== b.length) return 0;
  const dot = a.reduce((sum, val, i) => sum + val * b[i], 0);
  const magA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));
  const magB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));
  if (magA === 0 || magB === 0) return 0;
  return dot / (magA * magB);
}

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  // Validate request body
  const validation = matchRequestSchema.safeParse(req.body);
  if (!validation.success) {
    return res.status(400).json({ 
      error: 'Invalid request body',
      details: validation.error.format() 
    });
  }

  const { user_id, limit } = validation.data;
  const supabase = createSupabaseServer();

  try {
    // Note: User embedding lookup removed since users table doesn't exist
    // Will be implemented in Phase 20 with actual user embeddings
    const userEmbedding = null;
    console.log(`Fetching matches for user ${user_id}`);

    // Get ONLY active subscription trainers (PHASE 17 GATING LOGIC)
    const { data: trainers, error: trainersError } = await supabase
      .from('trainer_profiles')
      .select(`
        id,
        headline,
        bio,
        specialties,
        certifications,
        experience_years,
        hourly_rate,
        subscription_status,
        vector_embedding,
        ml_cluster_id
      `)
      .eq('subscription_status', 'active') // CRITICAL: Only active subscribers
      .limit(limit || 100);

    if (trainersError) {
      console.error('Error fetching trainers:', trainersError);
      return res.status(500).json({ error: 'Failed to fetch trainers' });
    }

    console.log(`Found ${trainers.length} active trainers`);

    // Calculate match scores
    const trainersWithScores = trainers.map((trainer: any) => {
      let similarityScore = 0;
      
      // Calculate embedding similarity if available (mocked for now)
      if (userEmbedding && trainer.vector_embedding) {
        try {
          similarityScore = cosineSimilarity(
            userEmbedding,
            trainer.vector_embedding as number[]
          );
        } catch (e) {
          console.error('Error calculating similarity:', e);
        }
      }

      // Weighted score formula (same as Phase 16 documentation)
      const matchScore = (
        0.55 * similarityScore +          // Embedding similarity (0 for now)
        0.25 * (trainer.ml_cluster_id ? 0.8 : 0.3) + // Cluster bonus
        0.20 * (trainer.experience_years ? Math.min(trainer.experience_years / 20, 1) : 0.5) // Experience
      );

      return {
        trainer: {
          id: trainer.id,
          headline: trainer.headline || 'Certified Fitness Trainer',
          bio: trainer.bio || 'Professional trainer with proven results',
          specialties: trainer.specialties || ['Strength Training', 'Cardio'],
          certifications: trainer.certifications || [],
          experience_years: trainer.experience_years || 3,
          hourly_rate: trainer.hourly_rate || 75,
          subscription_status: trainer.subscription_status
        },
        score: Math.min(Math.max(matchScore, 0), 1) // Clamp between 0-1
      };
    });

    // Sort by score (descending)
    trainersWithScores.sort((a: any, b: any) => b.score - a.score);

    // Return results
    return res.status(200).json({
      success: true,
      count: trainersWithScores.length,
      results: trainersWithScores.slice(0, limit || 20)
    });

  } catch (error: any) {
    console.error('Unexpected error in match API:', error);
    return res.status(500).json({ 
      error: 'Internal server error',
      message: error.message 
    });
  }
}